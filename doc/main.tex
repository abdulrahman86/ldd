
% {{{ preamble

\documentclass{article}

\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-timing}
\usepackage{nonfloat}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{fancyvrb}
\usepackage{parskip}

\usepackage{listings}
\lstset{numbers=left,
		language=C,
		tabsize=4,
		basicstyle=\ttfamily,
		%basicstyle=\footnotesize,
		showstringspaces=false,  % don't show the space character
		basicstyle=\normalsize,
		captionpos=b,
		xleftmargin=0.3in}

\usepackage{vmargin}  % make the margins a bit smaller
%\setmarginsrb{1.0in}{1.0in}{1.0in}{1.0in}{0in}{0.4in}{0.0in}{0.40in}
\setmarginsrb{1.0in}{1.0in}{1.0in}{1.0in}{0in}{0.25in}{0in}{0.20in}

\raggedright

\usepackage[backend=biber,autocite=footnote,
			bibstyle=authortitle,citestyle=verbose-inote]{biblatex}
\setlength{\bibitemsep}{\baselineskip}

\addbibresource{references.bib}

% }}}

\begin{document}

\VerbatimFootnotes

% {{{ title page

\thispagestyle{empty}

\centerline{\Large \textbf{Learning Linux Device Drivers}}
\vspace{0.1in}
\centerline{\normalsize {Jeremiah Mahler} ({\href{mailto:jmmahler@gmail.com}{jmmahler@gmail.com}})}
\centerline{\small \today}
\vspace{0.2in}

% }}}

\tableofcontents
\pagebreak

% {{{ Introduction
\section{Introduction}

\begin{figure*}[h!]
\begin{center}
\includegraphics[scale=0.6]{hierarchy/hier}
\end{center}
\caption{Hierarchy of kernel module examples.  Simplest at the
top downward to the more complex.}\label{fig:hier}
\end{figure*}

There are many excellent books about Linux device drivers
\autocite{corbet2009linux}
\autocite{venkateswaran2008essential}
\autocite{love2010linux}
\autocite{love2013linux}.
However, in this authors experience, they were difficult to learn from.
It certainly was not from their lack of detail.
Clearly each of the authors have a profound understanding of the Linux
kernel and their books reflect this.
If anything it is due to this lack of simplicity.

The drivers described in this document aim to be simple and concise.
Each one introduces as few concepts as possible.
And each driver is a fully working example
\footnote{If you think a driver might behave in a different way
if you changed something, try it and see.
This is a far better way to solidify your understanding than just
following the authors examples.}.
Many of the drivers are built in stages.
Each stage introduces a new concept.
And the changes can be concisely described showing the
differences (\verb+diff+).
Figure \ref{fig:hier} shows the hierarchy of driver examples.

% }}}

\section{Hello, World}
\subsection{hello}

The \verb+hello+ module (Listing \ref{lst:hello}) simply prints message
when it is loaded and unload.

\begin{verbatim}
hello$ make
 (should compile without error, resulting in hello.ko)
hello$ sudo insmod hello.ko
 Hello, World
hello$ sudo rmmod hello
 Goodbye, cruel world
\end{verbatim}

\lstinputlisting[float=ht,
				 caption={Hello, World module in hello/hello.c},
			 	 label={lst:hello}]
	{../hello/hello.c}

The \verb+module_init+ (line 18) and \verb+module_exit+ (line 19) tell
the kernel which functions to call when this module is
loaded (\verb+insmod+) and unloaded (\verb+rmmod+).

The \verb+__init+ (line 4) and \verb+__exit+ (line 10)
are optional hints for the compiler.  For example in the case of
\verb+__init+, this tells the kernel that it may discard the code
after initialization has been completed.

Both the init function (line 4) and the exit function (line 10)
are declared \verb+static+.
Since these functions are not meant to be used outside the scope
of this file, declaring them \verb+static+ enforces this
constraint\autocite[Pg. 52]{corbet2009linux}.

The \verb+printk+ statements are the \verb+printf+ of the
kernel domain.  There are various levels, in this case
\verb+KERN_ALERT+ is used which will cause the messages
to appear on the console.  Notice that there is no comma
between the level and the message.

The \verb+MODULE_AUTHOR+ and \verb+MODULE_LICENSE+ on lines 15 and 16
are optional but recommended\autocite[Pg. 51]{corbet2009linux}.
There are various other \verb+MODULE_*+
options as well (\verb+linux/module.h+).

\clearpage
\subsection{param}

The \verb+param+ module expands upon the \verb+hello+ module to
take a parameter specifying how many times to print the message.

\begin{verbatim}
param$ sudo insmod hello.ko howmany=2
 Hello, World
 Hello, World
param$ sudo rmmod hello
 Goodbye, cruel world
 Goodbye, cruel world
\end{verbatim}

Listing \ref{lst:param-diff} shows the differences between this
parameterized hello world module and the previous \verb+hello+ module.

\lstinputlisting[float=ht,
				 caption={param\$ diff -u hello.c ../hello/hello.c},
			 	 label={lst:param-diff}]
	{../param/diff}

To use a parameter a global variable has been created named \verb+howmany+
on line 8.
And on line 9 the \verb+module_param+ function is used to tell
the kernel about this parameter
\footnote{The \verb+module_param+ function create a sysfs entry
in \verb+/sys/module/parameters/howmany+.  \verb+sysfs+ will
be discussed in detail in later modules.}.

On lines 13-19 and 25-30 it can be seen that the same message
is printed \verb+howmany+ times.

\section{Read/Write Data}

The \verb+data+ module allocates a memory from ram which can
be read from and written to.
This is accomplished as a character device and supports all
the usual file operations.

\subsection{data\_chr}

The first step is to construct the basic infrastructure for
a character driver as shown in Listing \ref{lst:data_chr}.
It doesn't do anything useful but it will simplify the description
of upcoming drivers.

The \verb+DEVICE_NAME+ (line 8) is just a shortcut for the
name which is used in several places.

Lines 10-17 are the global variables that will be used.
The \verb+struct data_dev+ is the per device structure.
Notice that a character device is placed inside.

The \verb+file_operations+ (line 19-21) in this case only
defines the \verb+.owner+.  Upcoming modules will add references
to the open, close, read, write, and seek functions to this structure.

\verb+alloc_chrdev_region+ (line 26) allocates a major and minor number
for the character device\autocite[Pg. 66]{corbet2009linux}.
In this case only one major and minor pair is needed.

Functions such as \verb+alloc_chrdev_region+ may fail and when they
do anything that has been created up to that point must be undone
to ensure the kernel is left in a consistent state.
A common way this is done is using \verb+goto+ statements which
branch to different steps in the exit
sequence\autocite[Pg. 53]{corbet2009linux}.
It can be seen that if \verb+alloc_chrdev_region+ fails its \verb+goto+
(line 29) will branch to line 66.
Since nothing was created up to that point nothing has to be undone.

\verb+class_create+ (line 32) establishes a ``class'' for this
module which is also represented in sysfs under \verb+/sys/class/data+.
This object will be used later as an argument to \verb+device_create+.

Since the per device structure is just a pointer it must be
allocated before it is used (line 32).

To establish the character device it must be initialized and
added (lines 41-43).  And finally the device is created (line 49).
This device will now appear under \verb+/dev/fifo0+.

\lstinputlisting[caption={data\_chr driver.},
			 	 label={lst:data_chr}]
	{../data_chr/data.c}


%\lstinputlisting[linerange=26-30,
%				firstnumber=26]{../hello/hello.c}

\subsection{data\_rw}
\subsection{data\_sk}
\subsection{ioctlx}
\subsection{null}
\subsection{zero}

\section{Sysfs}
\subsection{sysx\_file}
\subsection{sysx\_file2}
\subsection{sysx\_group}
\subsection{sysx\_ktype}
\subsection{sysx\_ktype2}

\section{Concurrency}
\subsection{fifo\_rw}
\subsection{fifo\_sysfs}
\subsection{fifo\_xxx}
\subsection{fifo\_fix}

\pagebreak
\printbibliography

%\pagebreak
%\printindex

\end{document}
