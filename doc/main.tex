
% {{{ preamble

\documentclass{article}

\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-timing}
\usepackage{nonfloat}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{fancyvrb}
\usepackage{parskip}

\usepackage{courier}
\usepackage{listings}
\lstset{numbers=left,
		language=C,
		tabsize=4,
		basicstyle=\ttfamily,
		columns=fixed,
		showstringspaces=false,  % don't show the space character
		%commentstyle=\textit,
		showtabs=false,
		extendedchars=true,
		basicstyle=\footnotesize,
		captionpos=b,
		frame=tb,
		xleftmargin=0.3in}

\usepackage{vmargin}  % make the margins a bit smaller
%\setmarginsrb{1.0in}{1.0in}{1.0in}{1.0in}{0in}{0.4in}{0.0in}{0.40in}
\setmarginsrb{1.0in}{1.0in}{1.0in}{1.0in}{0in}{0.25in}{0in}{0.20in}

\raggedright

\usepackage[backend=biber,autocite=footnote,
			bibstyle=authortitle,citestyle=verbose-inote]{biblatex}
\setlength{\bibitemsep}{\baselineskip}

\addbibresource{references.bib}

% }}}

\begin{document}

\VerbatimFootnotes

% {{{ title page

\thispagestyle{empty}

\centerline{\Large \textbf{Learning Linux Device Drivers}}
\vspace{0.1in}
\centerline{\normalsize {Jeremiah Mahler} ({\href{mailto:jmmahler@gmail.com}{jmmahler@gmail.com}})}
\centerline{\small \today}
\vspace{0.2in}

% }}}

\tableofcontents
\pagebreak

% {{{ Introduction
\section{Introduction}

\begin{figure*}[h!]
\begin{center}
\includegraphics[scale=0.6]{hierarchy/hier}
\end{center}
\caption{Hierarchy of kernel module examples.  Simplest at the
top downward to the more complex.}\label{fig:hier}
\end{figure*}

\nocite{corbet2009linux}
\nocite{venkateswaran2008essential}
\nocite{love2010linux}
\nocite{love2013linux}

This project is a collection of Linux device driver examples.
Most are unique to this project.  But many are derived from
examples given in books and elsewhere.

A device driver can appear to be complex when taken as a whole.
But they are built upon simple concepts.
To emphasize this simplicity each driver is built in stages with
each stage introducing a new concept.
And the changes between stages can be easily viewed by looking
at the \verb+`diff+.

Figure \ref{fig:hier} shows the hierarchy of driver examples.

These examples were built using Kernel version 3.9 and 3.10.
They will likely work with other versions as well.
The Linux kernel changes fast but it usually isn't difficult to
determine what has changed and how it can be upgraded.

Each of the modules includes a Makefile to automate the build steps.

\begin{verbatim}
$ cd hello/
$ make
(should compile without error)
(and produce hello.ko)
$
\end{verbatim}

It may be necessary to install the kernel sources before compiling.
To do this under a Debian\autocite{debian} system the following steps
can be used.

\begin{verbatim}
$ uname -r
3.9-1-amd64
$ apt-get install linux-source-3.9 linux-headers-3.9-1-amd64

\end{verbatim}

% }}}

\section{Hello, World}

% {{{ hello
\subsection{hello}

The \verb+hello+ module (Listing \ref{lst:hello}) simply prints a message
when it is loaded/unloaded.

\begin{verbatim}
hello$ make
 (should compile without error, resulting in hello.ko)
hello$ sudo insmod hello.ko
 Hello, World
hello$ sudo rmmod hello
 Goodbye, cruel world
\end{verbatim}

\lstinputlisting[float=htpb,
				 caption={Hello, World module in hello/hello.c},
			 	 label={lst:hello}]
	{../hello/hello.c}

The \verb+module_init+ (line 18) and \verb+module_exit+ (line 19) tell
the kernel which functions to call when this module is
loaded (\verb+insmod+) and unloaded (\verb+rmmod+).

The \verb+__init+ (line 4) and \verb+__exit+ (line 10)
are optional hints for the compiler.  For example, in the case of
\verb+__init+, this tells the kernel that it may discard the code
after initialization has been completed.

Both the init function (line 4) and the exit function (line 10)
are declared \verb+static+.
Since these functions are not meant to be used outside the scope
of this file, declaring them \verb+static+ enforces this
constraint\autocite[Pg. 52]{corbet2009linux}.

The \verb+printk+ statements are the equivalent of a \verb+printf+ but
int the kernel domain.
One difference is that there are various alert levels.
In this case \verb+KERN_ALERT+ is used which will cause the messages
to appear on the console.
Notice that there is no comma between the level and the message.

The \verb+MODULE_AUTHOR+ and \verb+MODULE_LICENSE+ on lines 15 and 16
are optional but recommended\autocite[Pg. 51]{corbet2009linux}.
There are various other \verb+MODULE_*+
options as well (\verb+linux/module.h+).
% }}}

% {{{ param
\subsection{param}

The \verb+param+ module expands upon the \verb+hello+ module to
take a parameter specifying how many times to print the message.

\begin{verbatim}
param$ sudo insmod hello.ko howmany=2
 Hello, World
 Hello, World
param$ sudo rmmod hello
 Goodbye, cruel world
 Goodbye, cruel world
\end{verbatim}

Listing \ref{lst:param-diff} shows the differences between this
parameterized hello world module and the previous \verb+hello+ module.

\lstinputlisting[float=htpb,
				 caption={param\$ diff -u hello.c ../hello/hello.c},
			 	 label={lst:param-diff}]
	{../param/diff}

To use a parameter a global variable has been created named \verb+howmany+
on line 8.
And on line 9 the \verb+module_param+ function is used to tell
the kernel about this parameter
\footnote{The \verb+module_param+ function create a sysfs entry
in \verb+/sys/module/parameters/howmany+.  \verb+sysfs+ will
be discussed in detail in later modules.}.

On lines 13-19 and 25-30 it can be seen that the same message
is printed \verb+howmany+ times.
% }}}

\clearpage
\section{Character Devices}

The \verb+data+ module allocates some memory which can
then be read from and written to.
This is accomplished as a character device and supports all
the usual file operations.

% {{{ data_chr
\subsection{data\_chr}
\label{sec:data_chr}

The first step is to construct the basic infrastructure for
a character driver as shown in Listing \ref{lst:data_chr}.
It doesn't do anything useful but it will simplify the description
of upcoming drivers.

The \verb+DEVICE_NAME+ (line 8) is just a shortcut for the
name which is used in several places.

Lines 10-17 are the global variables that will be used.
The \verb+struct data_dev+ is the per device structure.
Notice that a character device is placed inside.

The \verb+file_operations+ (line 19-21) in this case only
defines the \verb+.owner+.  Upcoming modules will add references
to the open, close, read, write, and seek functions to this structure.

\verb+alloc_chrdev_region+ (line 26) allocates a major and minor number
for the character device\autocite[Pg. 66]{corbet2009linux}.
In this case only one major and minor pair is needed.

Functions such as \verb+alloc_chrdev_region+ may fail and when they
do anything that has been created up to that point must be undone
to ensure the kernel is left in a consistent state.
A common way this is done is using \verb+goto+ statements which
branch to different steps in the exit
sequence\autocite[Pg. 53]{corbet2009linux}.
It can be seen that if \verb+alloc_chrdev_region+ fails its \verb+goto+
(line 29) will branch to line 66.
Since nothing was created up to that point nothing has to be undone.

\verb+class_create+ (line 32) establishes a ``class'' for this
module which is also represented in sysfs under \verb+/sys/class/data+.
This object will be used later as an argument to \verb+device_create+.

Since the per device structure is just a pointer it must be
allocated before it is used (line 32).

To establish the character device it must be initialized and
added (lines 41-43).  And finally the device is created (line 49).
This device will now appear under \verb+/dev/data0+.

\pagebreak
\lstinputlisting[caption={data\_chr driver.},
			 	 label={lst:data_chr}]
	{../data_chr/data.c}


% }}}

% {{{ data_rw
\subsection{data\_rw}
\label{sec:data_rw}

With the addition of read/write operations the device can be
operated upon just like any other file.
As an example the driver source code can be copied in to the
device and then read back out.
The result should be the same up to the maximum amount which
in this case was 128 bytes.
This maximum size is a \verb+#define+ inside the driver.

\begin{verbatim}
$ sudo dd if=data.c of=/dev/data0 bs=128 count=1

$ sudo dd if=/dev/data0 of=output bs=128 count=1
\end{verbatim}

Listing \ref{lst:data_rw-diff} shows the differences compared to the
previous \verb+data_chr+ driver.  An array of bytes has been added
to the per device structure along with the current offset (lines 7-17).

File operations for open, read, write and release have been added (lines 82-88).
The release operation is called when a process closes the device file.

When the file is opened the open function (lines 19-29) is called.
The \verb+container_of+ function (line 23) is used to obtain a parent
structure from a child structure\autocite[Pg. 79]{corbet2009linux}
\autocite{kroah2005cont}.
Recall that the per device structure, \verb+data_devp+ contains a
\verb+cdev+ (line 14).
\verb+container_of+ makes it possible to obtain the \verb+data_devp+
from the \verb+cdev+.

The open functions sets the offset to zero (line 24) when is the usual
behavior when opening a file.

The open function also stores the device structure under \verb+private_data+
(line 26) so it is easy to access in the read/write functions.

When data is read from the device file the read function (lines 31-52)
is called.
Since the amount of data that can be read is limited by \verb+MAX_DATA+
the amount requested will be reduced it it is too large (lines 39-43).
Then the \verb+copy_to_user+ function is used to attempt to transfer
the data in to user space (lines 45-47).
The \verb+copy_to_user+ also hecks to make sure that destination it is
transferring to is valid for the given process.
If the transfer was a success the new offset is stored (line 49)
and then the number of bytes that were successfully transfered are
returned (line 51).

The write function (lines 54-70) has the same operation as read
except in the opposite directory.
Notice that the \verb+copy_from_user+ (line 68) function is used
in this case.

And since nothing needs to be done when the device is closed,
the release function (lines 77-80) simply returns success.

\pagebreak
\lstinputlisting[caption={data\_rw\$ diff -u ../data\_chr/data.c data.c},
			 	 label={lst:data_rw-diff}]
	{../data_rw/diff}

% }}}

% {{{ data_sk
\subsection{data\_sk}

To add support for the seek operation requires the addition of
one more function along with its corresponding entry in the
file operations.  Listing \ref{lst:data_sk-diff} shows the
differences.

\lstinputlisting[caption={data\_sk\$ diff -u ../data\_rw/data.c data.c},
			 	 label={lst:data_sk-diff}]
	{../data_sk/diff}

To test the seek operations a seek-able cat program named \verb+cats+
has been created.

\begin{verbatim}
jeri@crowe:~/ldd/data_sk/test$ sudo wc -c /dev/data0
128 /dev/data0
jeri@crowe:~/ldd/data_sk/test$ sudo dd if=cats.c of=/dev/data0 bs=128 count=1
jeri@crowe:~/ldd/data_sk/test$ sudo ./cats /dev/data0 END -28
t the reset of 'file.txt'
 *jeri@crowe:~/ldd/data_sk/test$ 
jeri@crowe:~/ldd/data_sk/test$ sudo ./cats /dev/data0 SET 100
t the reset of 'file.txt'
 *jeri@crowe:~/ldd/data_sk/test$ exit
\end{verbatim}

Notice that the file is 128 bytes total.
The output after seeking from the start forward 100 bytes produces
the same result as seeking backward 28 bytes from the end.
In this instance the device is operating correctly.

% }}}

% {{{ data_ioctl
\subsection{data\_ioctl}

Using \verb+ioctl()+ for new designs is not recommended\autocite[Pg. 156]{corbet2009linux}\autocite{love2010linux}.
Instead \verb+sysfs+ is preferred.
While \verb+/proc+ is another option, it is also becoming obsolete in
favor of \verb+sysfs+.
Nonetheless it is still used so it is worth knowing how it works.

Include with this driver is a test program (\verb+data_ioctl/test/ioctlx.c+).
The driver allows the reset, read and write of a single global variable
(\verb+x+) in the driver.
The test program allows these operations to be performed.

\begin{verbatim}
data_ioctl$ cd test/
test$ sudo ./ioctlx 10    # set value
test$ sudo ./ioctlx       # read current value
 10
test$ sudo ./ioctlx 0     # reset
test$ sudo ./ioctlx
 0
test$
\end{verbatim}

The \verb+data_ioctl+ driver has the fewest number of differences compared to
the \verb+data_chr+ driver (Section \ref{sec:data_chr}) as shown
in Listing \ref{lst:data_ioctl-diff}.
The open (lines 10-19) and release (lines 75-78) are the same as
those for the \verb+data_rw+ driver (Section \ref{sec:data_rw}).
The only code of interest is for the \verb+data_ioctl+ function (lines 29-73).

The first thing to notice is the use of "magic" (lines 23-25, 37).
Magic is used to make the ioctl calls unique across the entire system
which helps prevent inadvertent configuration if the wrong device is opened
\autocite[Pg. 158]{corbet2009linux}.
The user program must also contain the corresponding magic
values as is done in the test program (Listing \ref{lst:data_ioctl-magic}).

The three defines (lines 23-24) describe the supported ioctl operations.
Any number of additional operations can be added.
And it can be seen that there is an operation that has no data (\verb+_IO+),
reads data (\verb+_IOR+) and writes data (\verb+_IOW+).
The \verb+DATA_IOC_MAXNR+ (line 27) is used as a sanity check later (line 41).

And the switch statement (lines 53-70) process the ioctl commands.
In this case all the operations involve the global variable \verb+x+.
It is either reset, read or written.

\pagebreak
\lstinputlisting[caption={data\_ioctl\$ diff -u ../data\_chr/data.c data.c},
			 	 label={lst:data_ioctl-diff}]
	{../data_ioctl/diff}

\lstinputlisting[linerange=9-19,
				firstnumber=9,
				caption={Corresponding "magic" in user program.},
				label={lst:data_ioctl-magic}]
	{../data_ioctl/test/ioctlx.c}

% }}}

% {{{ null, zero
\subsection{null, zero}

From what has been described so far it is easy construct a driver
for the well known \verb+/dev/null+ and \verb+/dev/zero+ devices.

The zero device is even simpler than the \verb+data_rw+ example
(Section \ref{sec:data_rw}).
The only real difference, other than names (\verb+data+ -$>$ \verb+null+),
is the read and write operations as shown in Listing \ref{lst:null}.

\lstinputlisting[linerange=30-40,
				firstnumber=30,
				caption={/dev/null read and write functions.},
				label={lst:null}]
	{../null/null.c}

The read and write functions for the \verb+zero+ driver are also quite
simple (Listing \ref{lst:zero}.
The one new addition is the \verb+clear_user+ function.
It behaves like the \verb+copy_to_user+ function except that it simply
zeros out the users buffer.

\lstinputlisting[linerange=30-44,
				firstnumber=30,
				caption={/dev/zero read and write functions.},
				label={lst:zero}]
	{../zero/zero.c}

% }}}

% {{{ fifo_rw
\pagebreak
\subsection{fifo\_rw}
\label{sec:fifo_rw}

A FIFO (first in first out) can be constructed as a character device.
And it requires no new techniques beyond what was described for
the data driver (Section \ref{sec:data_rw}).

Several test programs are included (\verb+test/+) to simplify
experimenting with the fifo device.
The \verb+fifor+ and \verb+fifow+ programs can
be used to read and write numbers to the device.

The following example writes four numbers to the fifo and then
reads them back out.

\begin{verbatim}
test$ sudo ./fifow 10 11 12 13
test$ sudo ./fifor 4
10
11
12
test$
\end{verbatim}

Notice that only three values could be read out.
This is because by default the fifo size is three
(\verb+#define MAX_DATA+, line 9).
Once the fifo is full it cannot accept any more values.

The code for the \verb+fifo_rw+ is largely the same as the \verb+data_rw+
driver (Section \ref{sec:data_rw}).
The fifo is built using read and write pointers along with an empty flag.
When the module is initialized these values are
set (Listing \ref{lst:fifo_rw_init}).

\lstinputlisting[linerange=138-142,
				firstnumber=138,
				caption={fifo\_rw driver init.},
				label={lst:fifo_rw_init}]
	{../fifo_rw/fifo.c}

The read and write functions
(Listing \ref{lst:fifo_rw_read} and \ref{lst:fifo_rw_write})
have only algorithmic differences compared to the same operations in the
\verb+data_rw+ driver.

The fifo works a byte at a time,
trying to read/write until there are no more left or it runs out of room.
Since it can be both empty or full when the read pointer is at the
same position as the write pointer an empty flag is used.
Any successful write will make empty false
(Listing \ref{lst:fifo_rw_write}, lines 88-89).
Any successful read which results in the read pointer being the same as the
write pointer will make empty
true (Listing \ref{lst:fifo_rw_read}, lines 61-62).

\lstinputlisting[float=htpb,
				linerange=36-68,
				firstnumber=36,
				caption={fifo\_rw driver read function.},
				label={lst:fifo_rw_read}]
	{../fifo_rw/fifo.c}

\lstinputlisting[float=htpb,
				linerange=70-101,
				firstnumber=70,
				caption={fifo\_rw driver write function.},
				label={lst:fifo_rw_write}]
	{../fifo_rw/fifo.c}
% }}}

\clearpage
\section{Sysfs}

% {{{ fifo_sysfs

\subsection{fifo\_sysfs}

With the \verb+fifo_rw+ (Section \ref{sec:fifo_rw}) driver it was possible
to write values and read them back out in a first in first out manner.
But there was no way to get any info about the fifo from user space.
Things such as is it empty/full and where are the read/write pointers
at?

One way to create access to these metrics is by using Sysfs attributes.
Sysfs is a file system representation of all the objects in the kernel.
An ``attribute'' can be added to a kernel object (kobject) and
that attribute can appear as a file in \verb+/sys/+.
And this allows the value to read from or written to.

To add an attribute the first thing that must be added are the operations
for reading and writing.
With sysfs operations it is common to name them \emph{show} and \emph{store}
instead of read and write (Listing \ref{lst:fifo_sysfs_show}).

The \verb+DEVICE_ATTR+ macro is used to create a \verb+dev_attr+ structure
which will be used later when creating the file.
In this example \verb+read_offset+ (line 132) will create a variable named
\verb+dev_attr_read_offset+.

\lstinputlisting[float=htpb,
				linerange=117-153,
				firstnumber=117,
				caption={fifo\_sysfs driver show/store.},
				label={lst:fifo_sysfs_show}]
	{../fifo_sysfs/fifo.c}

There are many different kernel structures and attributes can be
added to any of them.
These other structures have their own attribute macro similar to
\verb+DEVICE_ATTR+ such as: \verb+DRIVER_ATTR+, \verb+CLASS_ATTR+,
\verb+BUS_ATTR+, etc.
Refer to \verb+linux/device.h+ for more info.

Adding an attribute to a kernel object does not necessarily create
a corresponding file in \verb+/sys/+.
To do this the \verb+device_create_file()+ function must be used
(Listing \ref{lst:fifo_sysfs_file}).
Notice that the \verb+dev_attr_*+ variable the was created earlier
is used along with \verb+fifo_device+ structure.

\lstinputlisting[float=htpb,
				linerange=203-211,
				firstnumber=203,
				caption={fifo\_sysfs driver attribute file creation.},
				label={lst:fifo_sysfs_file}]
	{../fifo_sysfs/fifo.c}

One thing that takes getting used to with Sysfs and kobject's is where
things end up under \verb+/sys/+.
It is often best to add the attributes to the most relevant object.
Then they will usually end up in a place that makes sense.
Trying to find the object that will place the file where you want it
is not the correct approach.

In this example the attributes end up under:

\begin{verbatim}
fifo_sysfs$ sudo find /sys -name 'read_offset'
/sys/devices/virtual/fifo/fifo0/read_offset
fifo_sysfs$ ls /sys/devices/virtual/fifo/fifo0
dev  power  read_offset  subsystem  uevent  write_offset
fifo_sysfs$ 
\end{verbatim}

Notice that both attributes that were created are there.
There are also some extra attributes that were automatically
created.

\begin{samepage}
Using these new attributes the test programs from the \verb+fifo_rw+
driver can be used to verify its operation.

\begin{verbatim}
test$ cat /sys/devices/virtual/fifo/fifo0/read_offset 
0
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset 
0
test$ sudo ./fifow 10 11
test$ cat /sys/devices/virtual/fifo/fifo0/read_offset 
0
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset 
2
test$ sudo ./fifor 1
10
test$ cat /sys/devices/virtual/fifo/fifo0/read_offset 
1
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset 
2
\end{verbatim}
\end{samepage}

As expected a write will increment the write offset by
the number of values written.
And a read will increase the read pointer by the number
of values read.

% }}}

\clearpage
\section{Concurrency}

For the sake of simplicity the examples up to this point have
ignored concurrency issues.
When multiple processes access a shared resource without restriction
(such as with mutexes or semaphores) the resulting race conditions
can wreak havoc.
For example if a pointer offset was incremented beyond its maximum
a write could easily crash the system.

Even if multiple processes access a resource the negative effects of
race conditions may still be unlikely and difficult to reproduce.
The technique used here is to first add code which makes the negative
effects virtually guaranteed.
And then it is shown how these problems can be fixed.

% {{{ fifo_xxx
\subsection{fifo\_xxx}

To magnify the effects of race conditions in the fifo driver
a pwait() function has been created.
This function forces the driver to wait for two processes
to arrive at that point before allowing them to proceeding on.
Listing \ref{lst:fifo_xxx-pwait} shows the additions.

\lstinputlisting[float=htbp,
				linerange=47-78,
				firstnumber=47,
				caption={Added pwait\_*() to fifo.c driver to create race
					conditions.},
				label={lst:fifo_xxx-pwait}]
	{../fifo_xxx/diff}

\begin{samepage}
While the addition of \verb+pwait_*()+ certainly magnifies the negative
effects of race conditions it still has a degree of unpredictability.
Inconsistent results are easily produced but the actual results vary.

In the following example two terminals are used to read and write values.
From terminal 1 the values 10 and 11 are written.
And at the same time terminal 2 writes the value 20 and 21.
Then they both try to read out all three of the stored values.

\begin{verbatim}
test$ cat /sys/devices/virtual/fifo/fifo0/read_offset
0
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset
0

test$ # (terminal 1)
test$ sudo ./fifow 10

test$ # (terminal 2)
test$ sudo ./fifow 20

test$ # (terminal 1)
test$ sudo ./fifow 11

test$ # (terminal 2)
test$ sudo ./fifow 21

test$ # (terminal 1)
test$ sudo ./fifor 3
10
20

test$ # (terminal 2)
test$ sudo ./fifor 3
20
11

test$ cat /sys/devices/virtual/fifo/fifo0/read_offset
1
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset
0

test$ # (terminal 1)
test$ sudo ./fifor 3
test$ # (terminal 2)
test$ sudo ./fifor 3
test$ # (empty?)

\end{verbatim}

It should be apparent that this driver has concurrency problems.
Four values were read out in total which is impossible since
the fifo size is three.
The value 20 was read twice.
And this reading of three values should have emptied the fifo
yet the offsets indicate otherwise since they are unequal.
Attempting to read more values indicates that it is empty.
The fifo should never have the empty flag set with non-equal
read and write offsets.
\end{samepage}

The code that is used to create these race conditions is interesting
because it uses mutexes (Listing \ref{lst:fifo_xxx-dpwait}).
Mutexes will be used to fix this code so that it doesn't suffer
from race condtions.

The first thing to notice about the code (Listing \ref{lst:fifo_xxx-dpwait})
is that it is a macro with a \verb+uid+ substitution.
Every place which has a \verb+##uid+ will be substituted with the
given unique id.
This uniqueness is needed to create unique mutexes.
This macro will create a function which can then be called.
For example \verb+DEFINE_PWAIT(read_fifo)+ results in the function
\verb+pwait_read_fifo()+.

The code works by using the variables \verb+in+ and \verb+out+.
Each process that enters the code and increments \verb+in+.
When \verb+in+ reaches two, two ins are removed and two outs are added
indicating that two process may leave.
Any process that leaves decrements \verb+out+.

Mutexes are used to limit access to each of the \verb+in+ and
\verb+out+ variables to only one process.
The code on lines 57-65 is an interesting example.
At first glance it may appear that the out mutex could be unlocked
twice.
But in fact the inner unlock is necessary because the break would
skip the outer unlock.
Forgetting the inner unlock would result in a deadlock since that lock
would never be unlocked.

\lstinputlisting[float=htbp,
				linerange=39-66,
				firstnumber=39,
				caption={pwait function used to creat race conditions in fifo\_xxx driver.},
				label={lst:fifo_xxx-dpwait}]
	{../fifo_xxx/fifo.c}

% }}}

\subsection{fifo\_fix}

The race conditions that ruined the operation of the \verb+fifo_xxx+
can be fixed using a single mutex.
In other situations it might be beneficial to make the control more
fine grained with multiple mutexes.
But in this example simplicity was important.

The first change that was made was to add a mutex to the
device structure (Listing \ref{lst:fifo_fix-devp}).
Some may wonder why this mutex was made device specific instead of global.
In this simple example either way would work.
But it is common to have multiple devices in which case it would be
undesireable for a mutex on one device to inhibit the operation on
some other device.

\lstinputlisting[float=htbp,
				linerange=1-9,
				firstnumber=1,
				caption={Mutex added to device structure.},
				label={lst:fifo_fix-devp}]
	{../fifo_fix/diff}

The code added to the read and write operations are nearly identical.
Listing \ref{lst:fifo_fix-read} shows the read operation differences.
The mutex is locked just before the code which must read or write the
shared variables.
And the mutex must be unlocked before this scope is exited.

\lstinputlisting[float=htbp,
				linerange=11-35,
				firstnumber=11,
				caption={Mutex added to read operation.
				Write operation is similar},
				label={lst:fifo_fix-read}]
	{../fifo_fix/diff}

And during initialization the mutex must be initialized
(Listing \ref{lst:fifo_fix-init}).
In contrast, when a global mutex is intialized this is often
accomplished as part of \verb+DEFINE_MUTEX+.

\lstinputlisting[float=htbp,
				linerange=60-68,
				firstnumber=60,
				caption={Mutex initialization.},
				label={lst:fifo_fix-init}]
	{../fifo_fix/diff}

\begin{samepage}
An example session with the driver using these changes is shown below.

\begin{verbatim}
test$ cat /sys/devices/virtual/fifo/fifo0/read_offset
0
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset
0

test$ # (terminal 1)
test$ sudo ./fifow 10

test$ # (terminal 2)
test$ sudo ./fifow 20

test$ # (terminal 1)
test$ sudo ./fifow 11

test$ # (terminal 2)
test$ sudo ./fifow 21

test$ # (terminal 1)
test$ sudo ./fifor 2
20
21

test$ # (terminal 2)
test$ sudo ./fifor 2
10

test$ cat /sys/devices/virtual/fifo/fifo0/read_offset
0
test$ cat /sys/devices/virtual/fifo/fifo0/write_offset
0
\end{verbatim}

It should be apparent that the driver no longer has any concurrency
problems.
Both terminals tried to write two values.
Since the fifo size is three one should be lost.
When each terminal tries to read two values it can be seen that only
obtain three in total, which is correct.
The order is difficult to predict but 21 coming after 20 is correct.
And it is interesting that terminal 2 received value 10 which was
written by terminal 1.
And finally it can be seen that the offsets are correct after all
values have been read out.

\end{samepage}

\pagebreak
\printbibliography

%\pagebreak
%\printindex

\end{document}
